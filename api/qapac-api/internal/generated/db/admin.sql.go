// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminCreateRoute = `-- name: AdminCreateRoute :one

INSERT INTO routes (name, active) VALUES ($1, true)
RETURNING id, name, active
`

// ==========================================================================
// Admin: Routes
// ==========================================================================
func (q *Queries) AdminCreateRoute(ctx context.Context, name string) (Route, error) {
	row := q.db.QueryRow(ctx, adminCreateRoute, name)
	var i Route
	err := row.Scan(&i.ID, &i.Name, &i.Active)
	return i, err
}

const adminCreateStop = `-- name: AdminCreateStop :one

INSERT INTO stops (name, geom, active)
VALUES ($1, ST_SetSRID(ST_MakePoint($2::float8, $3::float8), 4326), true)
RETURNING id, name, ST_X(geom) AS lon, ST_Y(geom) AS lat, active, created_at
`

type AdminCreateStopParams struct {
	Name string
	Lon  float64
	Lat  float64
}

type AdminCreateStopRow struct {
	ID        int32
	Name      string
	Lon       interface{}
	Lat       interface{}
	Active    pgtype.Bool
	CreatedAt pgtype.Timestamp
}

// ==========================================================================
// Admin: Stops
// ==========================================================================
func (q *Queries) AdminCreateStop(ctx context.Context, arg AdminCreateStopParams) (AdminCreateStopRow, error) {
	row := q.db.QueryRow(ctx, adminCreateStop, arg.Name, arg.Lon, arg.Lat)
	var i AdminCreateStopRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Lon,
		&i.Lat,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const adminDeactivateRoute = `-- name: AdminDeactivateRoute :exec
UPDATE routes SET active = false WHERE id = $1
`

func (q *Queries) AdminDeactivateRoute(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, adminDeactivateRoute, id)
	return err
}

const adminDeactivateStop = `-- name: AdminDeactivateStop :exec
UPDATE stops SET active = false WHERE id = $1
`

func (q *Queries) AdminDeactivateStop(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, adminDeactivateStop, id)
	return err
}

const adminDeleteRouteStops = `-- name: AdminDeleteRouteStops :exec
DELETE FROM route_stops WHERE route_id = $1
`

func (q *Queries) AdminDeleteRouteStops(ctx context.Context, routeID int32) error {
	_, err := q.db.Exec(ctx, adminDeleteRouteStops, routeID)
	return err
}

const adminGetRouteByID = `-- name: AdminGetRouteByID :one
SELECT id, name, active FROM routes WHERE id = $1
`

func (q *Queries) AdminGetRouteByID(ctx context.Context, id int32) (Route, error) {
	row := q.db.QueryRow(ctx, adminGetRouteByID, id)
	var i Route
	err := row.Scan(&i.ID, &i.Name, &i.Active)
	return i, err
}

const adminGetRouteShapeWKT = `-- name: AdminGetRouteShapeWKT :one
SELECT ST_AsText(geom) AS geom_wkt FROM route_shapes WHERE route_id = $1
`

func (q *Queries) AdminGetRouteShapeWKT(ctx context.Context, routeID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, adminGetRouteShapeWKT, routeID)
	var geom_wkt interface{}
	err := row.Scan(&geom_wkt)
	return geom_wkt, err
}

const adminGetRouteStops = `-- name: AdminGetRouteStops :many
SELECT stop_id, sequence FROM route_stops
WHERE route_id = $1
ORDER BY sequence ASC
`

type AdminGetRouteStopsRow struct {
	StopID   int32
	Sequence int32
}

func (q *Queries) AdminGetRouteStops(ctx context.Context, routeID int32) ([]AdminGetRouteStopsRow, error) {
	rows, err := q.db.Query(ctx, adminGetRouteStops, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminGetRouteStopsRow
	for rows.Next() {
		var i AdminGetRouteStopsRow
		if err := rows.Scan(&i.StopID, &i.Sequence); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetStopByID = `-- name: AdminGetStopByID :one
SELECT id, name, ST_X(geom) AS lon, ST_Y(geom) AS lat, active, created_at
FROM stops
WHERE id = $1
`

type AdminGetStopByIDRow struct {
	ID        int32
	Name      string
	Lon       interface{}
	Lat       interface{}
	Active    pgtype.Bool
	CreatedAt pgtype.Timestamp
}

func (q *Queries) AdminGetStopByID(ctx context.Context, id int32) (AdminGetStopByIDRow, error) {
	row := q.db.QueryRow(ctx, adminGetStopByID, id)
	var i AdminGetStopByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Lon,
		&i.Lat,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const adminInsertRouteStop = `-- name: AdminInsertRouteStop :exec
INSERT INTO route_stops (route_id, stop_id, sequence) VALUES ($1, $2, $3)
`

type AdminInsertRouteStopParams struct {
	RouteID  int32
	StopID   int32
	Sequence int32
}

func (q *Queries) AdminInsertRouteStop(ctx context.Context, arg AdminInsertRouteStopParams) error {
	_, err := q.db.Exec(ctx, adminInsertRouteStop, arg.RouteID, arg.StopID, arg.Sequence)
	return err
}

const adminListRoutes = `-- name: AdminListRoutes :many
SELECT id, name, active FROM routes
WHERE ($1::bool = false OR active = true)
ORDER BY id ASC
`

func (q *Queries) AdminListRoutes(ctx context.Context, activeOnly bool) ([]Route, error) {
	rows, err := q.db.Query(ctx, adminListRoutes, activeOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(&i.ID, &i.Name, &i.Active); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListStops = `-- name: AdminListStops :many
SELECT id, name, ST_X(geom) AS lon, ST_Y(geom) AS lat, active, created_at
FROM stops
WHERE ($1::bool = false OR active = true)
ORDER BY id ASC
`

type AdminListStopsRow struct {
	ID        int32
	Name      string
	Lon       interface{}
	Lat       interface{}
	Active    pgtype.Bool
	CreatedAt pgtype.Timestamp
}

func (q *Queries) AdminListStops(ctx context.Context, activeOnly bool) ([]AdminListStopsRow, error) {
	rows, err := q.db.Query(ctx, adminListStops, activeOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminListStopsRow
	for rows.Next() {
		var i AdminListStopsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Lon,
			&i.Lat,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdateRoute = `-- name: AdminUpdateRoute :exec
UPDATE routes SET name = $1, active = $2 WHERE id = $3
`

type AdminUpdateRouteParams struct {
	Name   string
	Active pgtype.Bool
	ID     int32
}

func (q *Queries) AdminUpdateRoute(ctx context.Context, arg AdminUpdateRouteParams) error {
	_, err := q.db.Exec(ctx, adminUpdateRoute, arg.Name, arg.Active, arg.ID)
	return err
}

const adminUpdateStop = `-- name: AdminUpdateStop :exec
UPDATE stops
SET name = $1, geom = ST_SetSRID(ST_MakePoint($2::float8, $3::float8), 4326), active = $4
WHERE id = $5
`

type AdminUpdateStopParams struct {
	Name   string
	Lon    float64
	Lat    float64
	Active pgtype.Bool
	ID     int32
}

func (q *Queries) AdminUpdateStop(ctx context.Context, arg AdminUpdateStopParams) error {
	_, err := q.db.Exec(ctx, adminUpdateStop,
		arg.Name,
		arg.Lon,
		arg.Lat,
		arg.Active,
		arg.ID,
	)
	return err
}

const adminUpsertRouteShape = `-- name: AdminUpsertRouteShape :exec
INSERT INTO route_shapes (route_id, geom, updated_at)
VALUES ($1, ST_GeomFromText($2, 4326), NOW())
ON CONFLICT (route_id)
DO UPDATE SET geom = ST_GeomFromText($2, 4326), updated_at = NOW()
`

type AdminUpsertRouteShapeParams struct {
	RouteID int32
	GeomWkt interface{}
}

func (q *Queries) AdminUpsertRouteShape(ctx context.Context, arg AdminUpsertRouteShapeParams) error {
	_, err := q.db.Exec(ctx, adminUpsertRouteShape, arg.RouteID, arg.GeomWkt)
	return err
}

const createAlert = `-- name: CreateAlert :one

INSERT INTO alerts (title, description, route_id, vehicle_plate, image_path, created_by)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, title, COALESCE(description, '') AS description, route_id,
          COALESCE(vehicle_plate, '') AS vehicle_plate,
          COALESCE(image_path, '') AS image_path, created_by, created_at
`

type CreateAlertParams struct {
	Title        string
	Description  pgtype.Text
	RouteID      pgtype.Int4
	VehiclePlate pgtype.Text
	ImagePath    pgtype.Text
	CreatedBy    pgtype.Int4
}

type CreateAlertRow struct {
	ID           int32
	Title        string
	Description  string
	RouteID      pgtype.Int4
	VehiclePlate string
	ImagePath    string
	CreatedBy    pgtype.Int4
	CreatedAt    pgtype.Timestamp
}

// ==========================================================================
// Admin: Alerts
// ==========================================================================
func (q *Queries) CreateAlert(ctx context.Context, arg CreateAlertParams) (CreateAlertRow, error) {
	row := q.db.QueryRow(ctx, createAlert,
		arg.Title,
		arg.Description,
		arg.RouteID,
		arg.VehiclePlate,
		arg.ImagePath,
		arg.CreatedBy,
	)
	var i CreateAlertRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.RouteID,
		&i.VehiclePlate,
		&i.ImagePath,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createVehicle = `-- name: CreateVehicle :one

INSERT INTO vehicles (plate_number, route_id, status)
VALUES ($1, $2, $3)
RETURNING id, plate_number, route_id, status, created_at
`

type CreateVehicleParams struct {
	PlateNumber string
	RouteID     pgtype.Int4
	Status      pgtype.Text
}

// ==========================================================================
// Admin: Vehicles
// ==========================================================================
func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle, arg.PlateNumber, arg.RouteID, arg.Status)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.PlateNumber,
		&i.RouteID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateOldAssignment = `-- name: DeactivateOldAssignment :exec
UPDATE vehicle_assignments SET active = false WHERE vehicle_id = $1 AND active = true
`

func (q *Queries) DeactivateOldAssignment(ctx context.Context, vehicleID int32) error {
	_, err := q.db.Exec(ctx, deactivateOldAssignment, vehicleID)
	return err
}

const deleteAlert = `-- name: DeleteAlert :exec
DELETE FROM alerts WHERE id = $1
`

func (q *Queries) DeleteAlert(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAlert, id)
	return err
}

const getActiveAssignment = `-- name: GetActiveAssignment :one
SELECT id, vehicle_id, driver_id, collector_id, assigned_at, active
FROM vehicle_assignments
WHERE vehicle_id = $1 AND active = true
`

func (q *Queries) GetActiveAssignment(ctx context.Context, vehicleID int32) (VehicleAssignment, error) {
	row := q.db.QueryRow(ctx, getActiveAssignment, vehicleID)
	var i VehicleAssignment
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.DriverID,
		&i.CollectorID,
		&i.AssignedAt,
		&i.Active,
	)
	return i, err
}

const getAlertByID = `-- name: GetAlertByID :one
SELECT id, title, COALESCE(description, '') AS description, route_id,
       COALESCE(vehicle_plate, '') AS vehicle_plate,
       COALESCE(image_path, '') AS image_path, created_by, created_at
FROM alerts
WHERE id = $1
`

type GetAlertByIDRow struct {
	ID           int32
	Title        string
	Description  string
	RouteID      pgtype.Int4
	VehiclePlate string
	ImagePath    string
	CreatedBy    pgtype.Int4
	CreatedAt    pgtype.Timestamp
}

func (q *Queries) GetAlertByID(ctx context.Context, id int32) (GetAlertByIDRow, error) {
	row := q.db.QueryRow(ctx, getAlertByID, id)
	var i GetAlertByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.RouteID,
		&i.VehiclePlate,
		&i.ImagePath,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getVehicleByID = `-- name: GetVehicleByID :one
SELECT id, plate_number, route_id, status, created_at
FROM vehicles
WHERE id = $1
`

func (q *Queries) GetVehicleByID(ctx context.Context, id int32) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByID, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.PlateNumber,
		&i.RouteID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const insertAssignment = `-- name: InsertAssignment :one
INSERT INTO vehicle_assignments (vehicle_id, driver_id, collector_id, active)
VALUES ($1, $2, $3, true)
RETURNING id, vehicle_id, driver_id, collector_id, assigned_at, active
`

type InsertAssignmentParams struct {
	VehicleID   int32
	DriverID    int32
	CollectorID pgtype.Int4
}

func (q *Queries) InsertAssignment(ctx context.Context, arg InsertAssignmentParams) (VehicleAssignment, error) {
	row := q.db.QueryRow(ctx, insertAssignment, arg.VehicleID, arg.DriverID, arg.CollectorID)
	var i VehicleAssignment
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.DriverID,
		&i.CollectorID,
		&i.AssignedAt,
		&i.Active,
	)
	return i, err
}

const listAlerts = `-- name: ListAlerts :many
SELECT id, title, COALESCE(description, '') AS description, route_id,
       COALESCE(vehicle_plate, '') AS vehicle_plate,
       COALESCE(image_path, '') AS image_path, created_by, created_at
FROM alerts
WHERE ($1::int IS NULL OR route_id = $1::int)
ORDER BY created_at DESC
`

type ListAlertsRow struct {
	ID           int32
	Title        string
	Description  string
	RouteID      pgtype.Int4
	VehiclePlate string
	ImagePath    string
	CreatedBy    pgtype.Int4
	CreatedAt    pgtype.Timestamp
}

func (q *Queries) ListAlerts(ctx context.Context, routeID pgtype.Int4) ([]ListAlertsRow, error) {
	rows, err := q.db.Query(ctx, listAlerts, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAlertsRow
	for rows.Next() {
		var i ListAlertsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.RouteID,
			&i.VehiclePlate,
			&i.ImagePath,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVehicles = `-- name: ListVehicles :many
SELECT id, plate_number, route_id, status, created_at
FROM vehicles
WHERE ($1::int IS NULL OR route_id = $1::int)
  AND ($2::text IS NULL OR status = $2::text)
ORDER BY created_at DESC
`

type ListVehiclesParams struct {
	RouteID pgtype.Int4
	Status  pgtype.Text
}

func (q *Queries) ListVehicles(ctx context.Context, arg ListVehiclesParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, listVehicles, arg.RouteID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.PlateNumber,
			&i.RouteID,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVehicle = `-- name: UpdateVehicle :exec
UPDATE vehicles SET plate_number = $1, route_id = $2, status = $3
WHERE id = $4
`

type UpdateVehicleParams struct {
	PlateNumber string
	RouteID     pgtype.Int4
	Status      pgtype.Text
	ID          int32
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) error {
	_, err := q.db.Exec(ctx, updateVehicle,
		arg.PlateNumber,
		arg.RouteID,
		arg.Status,
		arg.ID,
	)
	return err
}
