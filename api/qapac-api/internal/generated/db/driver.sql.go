// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: driver.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const endTrip = `-- name: EndTrip :execrows
UPDATE trips
SET status = 'completed', ended_at = NOW()
WHERE driver_id = $1 AND status = 'active'
`

func (q *Queries) EndTrip(ctx context.Context, driverID int32) (int64, error) {
	result, err := q.db.Exec(ctx, endTrip, driverID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getActiveTrip = `-- name: GetActiveTrip :one
SELECT id, vehicle_id, route_id, driver_id, started_at, ended_at, status
FROM trips
WHERE driver_id = $1 AND status = 'active'
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetActiveTrip(ctx context.Context, driverID int32) (Trip, error) {
	row := q.db.QueryRow(ctx, getActiveTrip, driverID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.RouteID,
		&i.DriverID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
	)
	return i, err
}

const getAssignmentByDriver = `-- name: GetAssignmentByDriver :one

SELECT va.vehicle_id, v.plate_number,
       COALESCE(rt.name, '') AS route_name,
       COALESCE(col.full_name, '') AS collector_name,
       va.assigned_at
FROM vehicle_assignments va
JOIN vehicles v ON v.id = va.vehicle_id
LEFT JOIN routes rt ON rt.id = v.route_id
LEFT JOIN users col ON col.id = va.collector_id
WHERE va.driver_id = $1 AND va.active = true
`

type GetAssignmentByDriverRow struct {
	VehicleID     int32
	PlateNumber   string
	RouteName     string
	CollectorName string
	AssignedAt    pgtype.Timestamp
}

// ==========================================================================
// Driver: Assignment
// ==========================================================================
func (q *Queries) GetAssignmentByDriver(ctx context.Context, driverID int32) (GetAssignmentByDriverRow, error) {
	row := q.db.QueryRow(ctx, getAssignmentByDriver, driverID)
	var i GetAssignmentByDriverRow
	err := row.Scan(
		&i.VehicleID,
		&i.PlateNumber,
		&i.RouteName,
		&i.CollectorName,
		&i.AssignedAt,
	)
	return i, err
}

const getVehicleRouteID = `-- name: GetVehicleRouteID :one
SELECT route_id FROM vehicles WHERE id = $1
`

func (q *Queries) GetVehicleRouteID(ctx context.Context, id int32) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getVehicleRouteID, id)
	var route_id pgtype.Int4
	err := row.Scan(&route_id)
	return route_id, err
}

const startTrip = `-- name: StartTrip :one

INSERT INTO trips (vehicle_id, route_id, driver_id, status)
VALUES ($1, $2, $3, 'active')
RETURNING id, vehicle_id, route_id, driver_id, started_at, ended_at, status
`

type StartTripParams struct {
	VehicleID int32
	RouteID   int32
	DriverID  int32
}

// ==========================================================================
// Driver: Trips
// ==========================================================================
func (q *Queries) StartTrip(ctx context.Context, arg StartTripParams) (Trip, error) {
	row := q.db.QueryRow(ctx, startTrip, arg.VehicleID, arg.RouteID, arg.DriverID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.RouteID,
		&i.DriverID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
	)
	return i, err
}

const upsertPosition = `-- name: UpsertPosition :exec

INSERT INTO vehicle_positions (vehicle_id, geom, heading, speed, recorded_at)
VALUES ($1, ST_SetSRID(ST_MakePoint($2::float8, $3::float8), 4326), $4, $5, NOW())
ON CONFLICT (vehicle_id)
DO UPDATE SET
    geom = ST_SetSRID(ST_MakePoint($2::float8, $3::float8), 4326),
    heading = $4,
    speed = $5,
    recorded_at = NOW()
`

type UpsertPositionParams struct {
	VehicleID int32
	Lon       float64
	Lat       float64
	Heading   pgtype.Float8
	Speed     pgtype.Float8
}

// ==========================================================================
// Driver: GPS position
// ==========================================================================
func (q *Queries) UpsertPosition(ctx context.Context, arg UpsertPositionParams) error {
	_, err := q.db.Exec(ctx, upsertPosition,
		arg.VehicleID,
		arg.Lon,
		arg.Lat,
		arg.Heading,
		arg.Speed,
	)
	return err
}
