// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: public.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFavorite = `-- name: AddFavorite :one
INSERT INTO favorites (device_id, route_id)
VALUES ($1, $2)
ON CONFLICT (device_id, route_id) DO UPDATE SET device_id = EXCLUDED.device_id
RETURNING id, device_id, route_id, created_at
`

type AddFavoriteParams struct {
	DeviceID string
	RouteID  int32
}

func (q *Queries) AddFavorite(ctx context.Context, arg AddFavoriteParams) (Favorite, error) {
	row := q.db.QueryRow(ctx, addFavorite, arg.DeviceID, arg.RouteID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.RouteID,
		&i.CreatedAt,
	)
	return i, err
}

const createRating = `-- name: CreateRating :one

INSERT INTO ratings (trip_id, rating, device_id)
VALUES ($1, $2, $3)
RETURNING id, trip_id, rating, device_id, created_at
`

type CreateRatingParams struct {
	TripID   int32
	Rating   int16
	DeviceID string
}

// ==========================================================================
// Public: Ratings
// ==========================================================================
func (q *Queries) CreateRating(ctx context.Context, arg CreateRatingParams) (Rating, error) {
	row := q.db.QueryRow(ctx, createRating, arg.TripID, arg.Rating, arg.DeviceID)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.Rating,
		&i.DeviceID,
		&i.CreatedAt,
	)
	return i, err
}

const findNearbyVehicles = `-- name: FindNearbyVehicles :many
SELECT v.id, v.plate_number, COALESCE(rt.name, '') AS route_name,
       ST_Y(vp.geom) AS lat, ST_X(vp.geom) AS lon
FROM vehicle_positions vp
JOIN vehicles v ON v.id = vp.vehicle_id
LEFT JOIN routes rt ON rt.id = v.route_id
WHERE v.status = 'active'
  AND ST_DWithin(vp.geom::geography, ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)::geography, $3::float8)
ORDER BY vp.geom::geography <-> ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)::geography
`

type FindNearbyVehiclesParams struct {
	Lon     float64
	Lat     float64
	RadiusM float64
}

type FindNearbyVehiclesRow struct {
	ID          int32
	PlateNumber string
	RouteName   string
	Lat         interface{}
	Lon         interface{}
}

func (q *Queries) FindNearbyVehicles(ctx context.Context, arg FindNearbyVehiclesParams) ([]FindNearbyVehiclesRow, error) {
	rows, err := q.db.Query(ctx, findNearbyVehicles, arg.Lon, arg.Lat, arg.RadiusM)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindNearbyVehiclesRow
	for rows.Next() {
		var i FindNearbyVehiclesRow
		if err := rows.Scan(
			&i.ID,
			&i.PlateNumber,
			&i.RouteName,
			&i.Lat,
			&i.Lon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclePosition = `-- name: GetVehiclePosition :one

SELECT ST_AsText(geom) AS geom_wkt, heading, speed, recorded_at
FROM vehicle_positions
WHERE vehicle_id = $1
`

type GetVehiclePositionRow struct {
	GeomWkt    interface{}
	Heading    pgtype.Float8
	Speed      pgtype.Float8
	RecordedAt pgtype.Timestamp
}

// ==========================================================================
// Public: Vehicle positions
// ==========================================================================
func (q *Queries) GetVehiclePosition(ctx context.Context, vehicleID int32) (GetVehiclePositionRow, error) {
	row := q.db.QueryRow(ctx, getVehiclePosition, vehicleID)
	var i GetVehiclePositionRow
	err := row.Scan(
		&i.GeomWkt,
		&i.Heading,
		&i.Speed,
		&i.RecordedAt,
	)
	return i, err
}

const listFavoritesByDevice = `-- name: ListFavoritesByDevice :many

SELECT f.id, f.device_id, f.route_id, COALESCE(rt.name, '') AS route_name, f.created_at
FROM favorites f
LEFT JOIN routes rt ON rt.id = f.route_id
WHERE f.device_id = $1
ORDER BY f.created_at DESC
`

type ListFavoritesByDeviceRow struct {
	ID        int32
	DeviceID  string
	RouteID   int32
	RouteName string
	CreatedAt pgtype.Timestamp
}

// ==========================================================================
// Public: Favorites
// ==========================================================================
func (q *Queries) ListFavoritesByDevice(ctx context.Context, deviceID string) ([]ListFavoritesByDeviceRow, error) {
	rows, err := q.db.Query(ctx, listFavoritesByDevice, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFavoritesByDeviceRow
	for rows.Next() {
		var i ListFavoritesByDeviceRow
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.RouteID,
			&i.RouteName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publicGetRouteByID = `-- name: PublicGetRouteByID :one
SELECT id, name, active FROM routes WHERE id = $1
`

func (q *Queries) PublicGetRouteByID(ctx context.Context, id int32) (Route, error) {
	row := q.db.QueryRow(ctx, publicGetRouteByID, id)
	var i Route
	err := row.Scan(&i.ID, &i.Name, &i.Active)
	return i, err
}

const publicGetRouteShapeWKT = `-- name: PublicGetRouteShapeWKT :one
SELECT ST_AsText(geom) AS geom_wkt FROM route_shapes WHERE route_id = $1
`

func (q *Queries) PublicGetRouteShapeWKT(ctx context.Context, routeID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, publicGetRouteShapeWKT, routeID)
	var geom_wkt interface{}
	err := row.Scan(&geom_wkt)
	return geom_wkt, err
}

const publicGetRouteStopsOrdered = `-- name: PublicGetRouteStopsOrdered :many
SELECT s.id, s.name, ST_AsText(s.geom) AS geom, rs.sequence
FROM route_stops rs
JOIN stops s ON s.id = rs.stop_id
WHERE rs.route_id = $1
ORDER BY rs.sequence
`

type PublicGetRouteStopsOrderedRow struct {
	ID       int32
	Name     string
	Geom     interface{}
	Sequence int32
}

func (q *Queries) PublicGetRouteStopsOrdered(ctx context.Context, routeID int32) ([]PublicGetRouteStopsOrderedRow, error) {
	rows, err := q.db.Query(ctx, publicGetRouteStopsOrdered, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PublicGetRouteStopsOrderedRow
	for rows.Next() {
		var i PublicGetRouteStopsOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Geom,
			&i.Sequence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publicGetRouteVehicles = `-- name: PublicGetRouteVehicles :many
SELECT v.id, v.plate_number, v.status,
       COALESCE(d.full_name, '') AS driver_name,
       COALESCE(col.full_name, '') AS collector_name
FROM vehicles v
LEFT JOIN vehicle_assignments va ON va.vehicle_id = v.id AND va.active = true
LEFT JOIN users d ON d.id = va.driver_id
LEFT JOIN users col ON col.id = va.collector_id
WHERE v.route_id = $1
ORDER BY v.plate_number
`

type PublicGetRouteVehiclesRow struct {
	ID            int32
	PlateNumber   string
	Status        pgtype.Text
	DriverName    string
	CollectorName string
}

func (q *Queries) PublicGetRouteVehicles(ctx context.Context, routeID pgtype.Int4) ([]PublicGetRouteVehiclesRow, error) {
	rows, err := q.db.Query(ctx, publicGetRouteVehicles, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PublicGetRouteVehiclesRow
	for rows.Next() {
		var i PublicGetRouteVehiclesRow
		if err := rows.Scan(
			&i.ID,
			&i.PlateNumber,
			&i.Status,
			&i.DriverName,
			&i.CollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publicGetRouteVehiclesWithPositions = `-- name: PublicGetRouteVehiclesWithPositions :many
SELECT v.id, v.plate_number, v.status,
       COALESCE(d.full_name, '') AS driver_name,
       COALESCE(col.full_name, '') AS collector_name,
       ST_AsText(vp.geom) AS pos_geom,
       vp.heading, vp.speed, vp.recorded_at
FROM vehicles v
LEFT JOIN vehicle_assignments va ON va.vehicle_id = v.id AND va.active = true
LEFT JOIN users d ON d.id = va.driver_id
LEFT JOIN users col ON col.id = va.collector_id
LEFT JOIN vehicle_positions vp ON vp.vehicle_id = v.id
WHERE v.route_id = $1 AND v.status = 'active'
ORDER BY v.plate_number
`

type PublicGetRouteVehiclesWithPositionsRow struct {
	ID            int32
	PlateNumber   string
	Status        pgtype.Text
	DriverName    string
	CollectorName string
	PosGeom       interface{}
	Heading       pgtype.Float8
	Speed         pgtype.Float8
	RecordedAt    pgtype.Timestamp
}

func (q *Queries) PublicGetRouteVehiclesWithPositions(ctx context.Context, routeID pgtype.Int4) ([]PublicGetRouteVehiclesWithPositionsRow, error) {
	rows, err := q.db.Query(ctx, publicGetRouteVehiclesWithPositions, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PublicGetRouteVehiclesWithPositionsRow
	for rows.Next() {
		var i PublicGetRouteVehiclesWithPositionsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlateNumber,
			&i.Status,
			&i.DriverName,
			&i.CollectorName,
			&i.PosGeom,
			&i.Heading,
			&i.Speed,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publicListRoutes = `-- name: PublicListRoutes :many

SELECT r.id, r.name, r.active,
       COUNT(v.id) FILTER (WHERE v.status = 'active')::int AS vehicle_count
FROM routes r
LEFT JOIN vehicles v ON v.route_id = r.id
WHERE r.active = true
GROUP BY r.id
ORDER BY r.name
`

type PublicListRoutesRow struct {
	ID           int32
	Name         string
	Active       pgtype.Bool
	VehicleCount int32
}

// ==========================================================================
// Public: Routes
// ==========================================================================
func (q *Queries) PublicListRoutes(ctx context.Context) ([]PublicListRoutesRow, error) {
	rows, err := q.db.Query(ctx, publicListRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PublicListRoutesRow
	for rows.Next() {
		var i PublicListRoutesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Active,
			&i.VehicleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavorite = `-- name: RemoveFavorite :exec
DELETE FROM favorites WHERE device_id = $1 AND route_id = $2
`

type RemoveFavoriteParams struct {
	DeviceID string
	RouteID  int32
}

func (q *Queries) RemoveFavorite(ctx context.Context, arg RemoveFavoriteParams) error {
	_, err := q.db.Exec(ctx, removeFavorite, arg.DeviceID, arg.RouteID)
	return err
}
